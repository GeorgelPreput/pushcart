# Pushcart Log Handlers

This document describes how to create and plug custom log handlers into the Pushcart framework. Log handlers extend Python's built-in logging.Handler class and can be used to process and store log records generated by the application.

## Creating a Custom Log Handler

To create a custom log handler, follow these steps:

1. Create a new Python package in your project or a standalone package that follows the naming convention `pushcart_<handler_name>`. For example, `pushcart_myhandler`.
1. Inside the package, create a `log_handlers` directory.
1. In the `log_handlers` directory, create a Python file with the name `<handler_name>.py`, for example, `myhandler.py`.
1. Inside `<handler_name>.py`, create a custom log handler class that inherits from `logging.Handler`:

```python
import logging

class MyHandler(logging.Handler):
    def __init__(self, config):
        super().__init__()
        # Initialize your custom log handler with the provided config

    def emit(self, record):
        # Process the log record
        log_entry = self.format(record)
        # Send the log entry to the desired destination (e.g., a file, a database, etc.)
```

5. Implement the __init__ method to initialize your custom log handler with the provided config dictionary.
1. Implement the emit method to process log records and send them to the desired destination.

## DeltaTableHandler

`DeltaTableHandler` is a custom logging handler for Python's built-in `logging` library. It allows you to store log records in a Delta Lake table, which is a scalable and distributed data storage format built on top of Apache Spark. This handler is particularly useful when you need to manage and query large volumes of log data efficiently.

### How it works

The `DeltaTableHandler` writes log records to a specified Delta table path. The log records are buffered in a queue, and the buffer is flushed to the Delta table at regular intervals or when the buffer is full. The handler uses PySpark to write log records to the Delta table, which supports concurrent reads and writes, making it suitable for distributed applications.

### Usage

To use `DeltaTableHandler`, you need to import the necessary libraries and create an instance of the handler. Then, add the handler to your logger.

```python
import logging
from pushcart.log_handlers import DeltaTableHandler

# Create an instance of DeltaTableHandler
table_path = "/path/to/delta/table"
buffer_size = 100
flush_interval = 15
delta_handler = DeltaTableHandler(table_path, buffer_size, flush_interval)

# Configure your logger
logger = logging.getLogger("my_logger")
logger.setLevel(logging.INFO)
logger.addHandler(delta_handler)

# Log messages as usual
logger.info("This is an info message.")
logger.error("This is an error message.")
```

### Parameters

- `table_path` (str): The path to the Delta table where log records will be stored. If the table doesn't exist, it will be created automatically.
- `buffer_size` (int, optional): The maximum number of log records to buffer before flushing them to the Delta table. Default is 100.
- `flush_interval` (int, optional): The time interval (in seconds) at which the buffer is flushed to the Delta table. Default is 15.

### Log record schema

The log records are stored in the Delta table with the following schema:

- `timestamp`: Timestamp of when the log record was created.
- `origin`: The name of the logger that created the log record.
- `level`: The level of the log record (e.g., "INFO", "ERROR", "WARNING", etc.).
- `message`: The log message.

### Best practices

1. Be mindful of the buffer size and flush interval settings. A larger buffer size may result in reduced write operations, but can also cause memory issues or data loss in case of application crashes. Adjust these settings according to your application's requirements and resources.

1. The `DeltaTableHandler` class automatically calls its `close()` method when the object is destroyed, thanks to the `__del__()` method. This ensures that any remaining log records in the buffer are flushed to the Delta table, and the flush timer is canceled when the object is destroyed.  
By implementing the `__del__()` method in the DeltaTableHandler class, the need for manual intervention is reduced, making it more convenient and reliable for users.  
However, keep in mind that the `__del__()` method is not guaranteed to be called immediately when the object goes out of scope, as it depends on Python's garbage collector. In most cases, it should be sufficient to ensure that `close()` is called eventually. If you need to ensure that the `close()` method is called immediately and deterministically, you can still call it manually:

```python
handler.close()
```

3. Consider using a log formatter to customize the format of your log messages. You can do this by creating an instance of logging.Formatter and setting it as the formatter for the DeltaTableHandler.

```python
formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
delta_handler.setFormatter(formatter)
```
